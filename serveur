#! /bin/bash

# Ce script implémente un serveur.  
# Le script doit être invoqué avec l'argument :                                                              
# PORT   le port sur lequel le serveur attend ses clients  

if [ $# -ne 1 ]; then
    echo "usage: $(basename $0) PORT"
    exit -1
fi


PORT="$1"

# Déclaration du tube

FIFO="/tmp/$USER-fifo-$$"

# Il faut détruire le tube quand le serveur termine pour éviter de
# polluer /tmp.  On utilise pour cela une instruction trap pour être sur de
# nettoyer même si le serveur est interrompu par un signal.

function nettoyage() { rm -f "$FIFO"; }
trap nettoyage EXIT #QUand on va quitter le server il va y avoir un exit qui est envoyé et le trap quand il verra le exit il va executer nettoyage

#trap fonction EXIT: des que le programme execute EXIT

# on crée le tube nommé

[ -e "FIFO" ] || mkfifo "$FIFO"


function accept-loop() {
    while true; do
	interaction < "$FIFO" | netcat -kl -p "$PORT" > "$FIFO"
    done
}

# La fonction interaction lit les commandes du client sur entrée standard 
# et envoie les réponses sur sa sortie standard. 
#
# 	CMD arg1 arg2 ... argn                   
#                     
# alors elle invoque la fonction :
#                                                                            
#         commande-CMD arg1 arg2 ... argn                                      
#                                                                              
# si elle existe; sinon elle envoie une réponse d'erreur.                     

modeBrowse=false

function interaction() {
    local cmd args arg1
    while true; do
	read cmd args arg1 || exit -1
	fun="commande-$cmd"
	
	if [ "$(type -t $fun)" = "function" ]; then 
	#Si la chaine de caractere est bien une fonction préalablement définie
		$fun $args
	else
	    commande-non-comprise $fun $args
	fi
    done
}
# Les fonctions implémentant les différentes commandes du serveur

function commande-non-comprise () {
	echo $mode
   echo "Le serveur ne peut pas interpréter cette commande"
}

# On accepte et traite les connexions

function commande-echo () {

	if [ $args="bonjour" ];then
	
		echo "Bonjour, je suis à votre service"
	else
		echo "TU veux quoi"
	fi

	}


function commande-convert () {
	echo $args | tr [a-z] [A-Z]
}

function commande-convert2 () {
	echo $* | awk'{print toupper($0)}'
}

function commande-extinction () {
	sleep 10
	shutdown -r
}

function commande-touch () {
	if [ -f $1 ];then
		echo "dsl fichier deja exitant"
	else
		touch $1
		echo blabla > $1
	fi
	}

function commande-list () {

	ls=$(ls ~/projet/archive)
	if [ -n "$ls" ]; then
		echo -e "\nLes archives existantes sont: \n\n$ls"
	else
		echo "Pas d'archive dans ce serveur"
	fi
}

function commande-create () {

	#cmd contiens le mode
	#echo $cmd

	#args contient le nom de l'archive
	#echo -e "$args je suis args\n\n\n\n\n"

	#arg1 contient le path du directory je sais pas pourquoi
	#echo -e "$arg1 JE suis arg1\n\n\n\n\n"

	#arg2 contient le contenu du fichier

	mv $args archive/$args
	
}

function commande-extract () {

	#echo "$args est args" 
	arch=$(echo $args)
	#echo "$arch je suis l'archive"
	sed 's/\\/\//g' archive/$arch > archExtract
	cat archExtract
	rm archExtract
	
}

#function commande-vsh () {
#	
#	if [ $# -ne 0 ];then
#		if [ "$mode" = "-list" ];then
#			ls=$(ls ~/projet/archive)
#			if [ -n "$ls" ];then
#				echo -e "\nLes archives existantes sont:\n\n$ls"
#			else
#				echo "Pas d'archive dans ce serveur"
#			fi
#			
#		elif [ "$1" = "-browse" ];then
#			modeBrowse=true	
#			echo -n "vsh:>"
#
#		elif [ "$1" = "-create" ]; then
#				
#			for i in $(ls $(pwd)/archive)
#			do
#				if [ -d $i ]; then
#					echo "Directory: $(pwd)/$i/"
#					"rechercheDossier"
#
#				fi
#				set -- $(ls -l | grep $i)
#				
#				echo $9 $1 $5
#	
#			done
#
#
#		fi
#		
#	else
#		echo "Rentre une commande"
#	fi
#}



function rechercheDossier () { 
	for i in $(ls)
	do
		echo "Directory: $(pwd)/$i"
		set --$(ls -l | grep $i)
		echo $9 $1 $5

	done


}

#repcourant="\\"




function commande-browse () {
	echo $args
	repcourant=$(cat archive/$args | head -3 | tail -1 | cut -d' ' -f2)
	while true; do
	echo -n "vsh:>"
	read arg fichier option
	if [ "$arg" = "pwd" ]; then
	commande-pwd $repcourant
	elif [ "$arg" = "ls" ]; then
		commande-ls $args $fichier $repcourant $option
	elif [ "$arg" = "cat" ]; then
		commande-cat $args $fichier $option $repcourant
	elif [ "$arg" = "rm" ]; then
		commande-rm $args $fichier $repcourant
	fi
	done
}


#mystr=$(commande-$cmd)
#echo $mystr



function commande-pwd () {
	echo "Le rep courant est $repcourant"
}

function commande-ls () {

#path=$(sed -n "3 p" archive/$args | cut -d' ' -f2)
sed 's/\\/\\\\/g' archive/$args > lsarch
while read ligne 
do
set -- $ligne
if [[ "$fichier" = "" || "$fichier" = "-l" ]]; then
	if [ "$ligne" = "@" ]; then
		break
	else
		if [[ ! "$3" = "" ]];then
			if [ "$fichier" = "-l" ]; then
				echo "$2 $3 $1"
			else
				if [[ "$2" =~ ^d ]]; then
				echo -n "$1\ "
				else
					droit=$(echo $2 | cut -c4)
					if [[ "$droit" = "x" ]]; then
						echo -n "$1* "
					else
						echo -n "$1 "
					fi
				fi
			fi
		fi
	fi
else
	fichier=$(echo $fichier | sed 's/\//\\/g')
	if [[ "$repcourant" =~ \\$ ]];then
	pathls=$(echo $repcourant$fichier | sed 's/\\/\\\\/g')
	else
	pathls=$(echo $repcourant\\$fichier | sed 's/\\/\\\\/g')
	fi
	li=$(grep -n "${pathls}$" archive/$args | head -1 | cut -d':' -f1)
	if [ "$li" = "" ]; then
		echo "ls : cannot access '$fichier' : No such file or directory"
		break
	else

		sed -n "$li,$ p" archive/$args > bouclels
		while read ligne; do
			if [ "$ligne" = "@" ]; then
			finli=$(grep -n "${ligne}" bouclels| cut -d':' -f1 | head -1)
			finli=$(echo "$(($finli+$li))")
			break
			fi
		done < bouclels
		finli=$(($finli-2))
		li=$(($li+1))
		sed -n "$li, $finli p" archive/$args > echols
		while read ligne; do
			set -- $ligne
			if [[ "$2" =~ ^d ]]; then
				echo -n "$1\ "
			else
				droit=$(echo $2 | cut -c4)
				if [[ "$droit" = "x" ]]; then
					echo -n "$1* "
				else
					echo -n "$1 "
				fi
			fi
		done < echols
		rm echols
		rm bouclels
		break
	fi 	
fi	

done < lsarch
echo -e "\n"
rm lsarch

}

function commande-cat () {

sed 's/\\/\\\\/g' archive/$args > lsarch
while read ligne 
do
set -- $ligne
if [[ "$fichier" = "" ]]; then
	echo "Usage cat fich"
	break
else

	li=$(grep -n "^${fichier} " archive/$args | head -1 | cut -d':' -f1)
	if [ "$li" = "" ]; then
		echo "cat: $fichier: No such file or directory"
		break
	else
		if [[ ! "$option" = "" ]]; then
			li2=$(grep -n "^${option} " archive/$args | head -1 | cut -d':' -f1)
			if [ "$li2" = "" ]; then
				echo "cat: $option: No such file or directory"
				break
			fi
		fi
		repc=$(echo $repcourant | sed 's/\\/\\\\/g')
		repc=$(grep -n "${repc}$" archive/$args | head -1 | cut -d':' -f1)
		sed -n "$repc,$ p" archive/$args > bouclels
		while read ligne; do
			if [ "$ligne" = "@" ]; then
			finli=$(grep -n "${ligne}" bouclels| cut -d':' -f1 | head -1)
			finli=$(echo "$(($finli+$repc))")
			break
			fi
		done < bouclels
		finli=$(($finli-2))
		repc=$(($repc+1))
		sed -n "$repc, $finli p" archive/$args | cut -d' ' -f1 > echols
		verif=0
		verif2=0
		while read ligne; do
			if [ "$option" = "" ];then
				if [[ $ligne =~ ^${fichier}$ ]]; then
					verif=1
				fi
			elif [[ "$option" = "$fichier" ]]; then
				if [[ $ligne =~ ^${fichier}$ ]]; then
					verif=1
					verif2=1
				fi
			else
				if [[ $ligne =~ ^${fichier}$ ]]; then
					verif=1
				elif [[ $ligne =~ ^${option}$ ]]; then
					verif2=1
				fi
			fi
		done < echols
		rm bouclels
		rm echols
		if [[ "$option" = "" ]]; then	
			if [[ "$verif" = 0 ]]; then
				echo "cat: $fichier: No such file or directory"
				break
			else
				sed -n "$li p" archive/$args > tempcat
				while read ligne; do
					set -- $ligne
					deb=$4
					long=$5
				done < tempcat
				rm tempcat
				if [[ "$deb" = "" ]]; then
					echo "cat: $fichier: Is a directory"
					break
				else 
					deb_body=$(cat archive/$args | head -1 | cut -d':' -f2)		
					deb=$(($deb+$deb_body-1))
					fin=$(($deb+$long-1))
					sed -n "$deb, $fin p" archive/$args
					break
				fi
			fi
		else
			if [[ "$verif" = 0 ]]; then
				echo "cat: $fichier: No such file or directory"
				break
			elif [[ "$verif2" = 0 ]]; then
				echo "cat: $option: No such file or directory"
				break
			else
				sed -n "$li p" archive/$args > tempcat
				while read ligne; do
					set -- $ligne
					deb=$4
					long=$5
				done < tempcat
				rm tempcat
				sed -n "$li2 p" archive/$args > tempcat2
				while read ligne; do
					set -- $ligne
					deb2=$4
					long2=$5
				done < tempcat2
				rm tempcat2
				if [[ "$deb" = "" ]]; then
					echo "cat: $fichier: Is a directory"
					break
				elif [[ "$deb2" = "" ]];then
					echo "cat: $option: Is a directory"
					break
				else 
					deb_body=$(cat archive/$args | head -1 | cut -d':' -f2)		
					deb=$(($deb+$deb_body-1))
					fin=$(($deb+$long-1))
					sed -n "$deb, $fin p" archive/$args

					deb2=$(($deb2+$deb_body-1))
					fin2=$(($deb2+$long2-1))
					sed -n "$deb2, $fin2 p" archive/$args
					break
				fi
				
				
			fi	
		fi
	fi		
fi	

done < lsarch
#echo -e "\n"
rm lsarch

}


function commande-rm () {

sed 's/\\/\\\\/g' archive/$args | cut -d' ' -f1 > lsarch
while read ligne 
do
set -- $ligne
if [[ "$fichier" = "" ]]; then
	echo "Usage rm fich"
	break
else
	li=$(grep -n "$fichier " archive/$args | cut -d':' -f1)
	echo "$li je suis li"
	if [ "$li" = "" ]; then
		echo "rm: cannot remove '$fichier': No such file or directory"
		break
	else
		repc=$(echo $repcourant | sed 's/\\/\\\\/g')
		repc=$(grep -n "${repc}$" archive/$args | cut -d':' -f1)
		sed -n "$repc,$ p" archive/$args > bouclels
		while read ligne; do
			if [ "$ligne" = "@" ]; then
			finli=$(grep -n "${ligne}" bouclels| cut -d':' -f1 | head -1)
			finli=$(echo "$(($finli+$repc))")
			break
			fi
		done < bouclels
		finli=$(($finli-2))
		repc=$(($repc+1))
		sed -n "$repc, $finli p" archive/$args | cut -d' ' -f1 > echols
		verif=0
		while read ligne; do
			if [[ $ligne =~ ^${fichier}$ ]]; then
				verif=1
			fi
		done < echols
		rm bouclels
		rm echols	
		if [[ "$verif" = 1 ]]; then
			sed -n "$li p" archive/$args > tempcat
			ok=0
				while read ligne; do
					set -- $ligne
					if [[ ! "$4" = "" ]]; then
						ok=1
					fi
				done < tempcat
				rm tempcat
			if [[ "$ok" = 0 ]]; then
				echo "rm: cannot remove '$fichier': Is a directory"
			else
				sed "$li d" archive/$args > archive/$args
				deb_body=$(cat archive/$args | head -1 | cut -d':' -f2)		

				echo "je suis dans verif = $verif"
				break
			fi
		else
			echo "rm: cannot remove '$fichier': No such file or directory"
			break
		fi		
	fi
fi
done < lsarch



}







accept-loop
