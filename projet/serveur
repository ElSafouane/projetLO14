#! /bin/bash

# Ce script implémente un serveur.  
# Le script doit être invoqué avec l'argument :                                                              
# PORT   le port sur lequel le serveur attend ses clients  

if [ $# -ne 1 ]; then
    echo "usage: $(basename $0) PORT"
    exit -1
fi


PORT="$1"

# Déclaration du tube

FIFO="/tmp/$USER-fifo-$$"

# Il faut détruire le tube quand le serveur termine pour éviter de
# polluer /tmp.  On utilise pour cela une instruction trap pour être sur de
# nettoyer même si le serveur est interrompu par un signal.

function nettoyage() { rm -f "$FIFO"; }
trap nettoyage EXIT #QUand on va quitter le server il va y avoir un exit qui est envoyé et le trap quand il verra le exit il va executer nettoyage

#trap fonction EXIT: des que le programme execute EXIT

# on crée le tube nommé

[ -e "FIFO" ] || mkfifo "$FIFO"


function accept-loop() {
    while true; do
	interaction < "$FIFO" | netcat -kl -p "$PORT" > "$FIFO"
    done
}

# La fonction interaction lit les commandes du client sur entrée standard 
# et envoie les réponses sur sa sortie standard. 
#
# 	CMD arg1 arg2 ... argn                   
#                     
# alors elle invoque la fonction :
#                                                                            
#         commande-CMD arg1 arg2 ... argn                                      
#                                                                              
# si elle existe; sinon elle envoie une réponse d'erreur.                     

modeBrowse=false

function interaction() {
    local cmd args
    while true; do
	read cmd args || exit -1
	
	fun="commande-$cmd"
	if $modeBrowse;then
		echo "Oui bien joué"
		fun="browse-$cmd"
		if [ "$cmd" = "exit" ];then
			modeBrowse=false
			fun="commande-$cmd"
		fi
	fi
	if [ "$(type -t $fun)" = "function" ]; then 
	#Si la chaine de caractere est bien une fonction préalablement définie
	    $fun $args
	else
	    commande-non-comprise $fun $args
	fi
    done
}

# Les fonctions implémentant les différentes commandes du serveur


function commande-non-comprise () {
	echo $mode
   echo "Le serveur ne peut pas interpréter cette commande"
}

# On accepte et traite les connexions

function commande-echo () {

	if [ $args="bonjour" ];then
	
		echo "Bonjour, je suis à votre service"
	else
		echo "TU veux quoi"
	fi

	}


function commande-convert () {
	echo $args | tr [a-z] [A-Z]
}

function commande-convert2 () {
	echo $* | awk'{print toupper($0)}'
}

function commande-extinction () {
	sleep 10
	shutdown -r
}

function commande-touch () {
	if [ -f $1 ];then
		echo "dsl fichier deja exitant"
	else
		touch $1
		echo blabla > $1
	fi
	}

function commande-list () {
	ls=$(ls ~/projet/archive)
	if [ -n "$ls" ]; then
		echo -e "\nLes archives existantes sont: \n\n$ls"
	else
		echo "Pas d'archive dans ce serveur"
	fi
	echo $cmd
}

function commande-create () {
	echo "create"
	echo $cmd
}


#function commande-vsh () {
#	
#	if [ $# -ne 0 ];then
#		if [ "$mode" = "-list" ];then
#			ls=$(ls ~/projet/archive)
#			if [ -n "$ls" ];then
#				echo -e "\nLes archives existantes sont:\n\n$ls"
#			else
#				echo "Pas d'archive dans ce serveur"
#			fi
#			
#		elif [ "$1" = "-browse" ];then
#			modeBrowse=true	
#			echo -n "vsh:>"
#
#		elif [ "$1" = "-create" ]; then
#				
#			for i in $(ls $(pwd)/archive)
#			do
#				if [ -d $i ]; then
#					echo "Directory: $(pwd)/$i/"
#					"rechercheDossier"
#
#				fi
#				set -- $(ls -l | grep $i)
#				
#				echo $9 $1 $5
#	
#			done
#
#
#		fi
#		
#	else
#		echo "Rentre une commande"
#	fi
#}
#



function rechercheDossier () { 
	for i in $(ls)
	do
		echo "Directory: $(pwd)/$i"
		set --$(ls -l | grep $i)
		echo $9 $1 $5

	done


}




repCourant="/"

function commande-cat () {
	cat $1

}

function commande-pwd () {
	pwd $1

}


function browse-ls () {
	ls -l

}


function browse-pwd () {
	echo $repCourant
}


accept-loop
